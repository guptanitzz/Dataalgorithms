import pandas as pd
import numpy as np
import random

#Bubble Sort 

# Bubble Sort is an algorithm which is used to sort N elements that are given in a memory
# for eg: an Array with N number of elements. Bubble Sort compares all the element one by 
# one and sort them based on their values

def BubbleSort(ls):
  for i in range(0,len(ls)):
      #print(i)
      flag=0
      for j in range(0,len(ls)-i-1):
          #print(j)
          t=0
          #print(ls)
          if ls[j+1]<ls[j]:
              t=ls[j]
              ls[j]=ls[j+1]
              ls[j+1]=t
              flag=1
          #print(ls)
      if(flag==0):
          break
  return ls
 
        
 ###Time Complexity
 
 #Best case O(n^2)
 #Worst case O(n^2)
 #Average Case O(n) (If already sorted array os passed)


#Insertion sorting
# It is a simple Sorting algorithm which sorts the array by shifting elements one by one.
# It has one of the simplest implementation
# It is efficient for smaller data sets, but very inefficient for larger lists.
# Insertion Sort is adaptive, that means it reduces its total number of steps if given a partially sorted list, hence it increases its efficiency.
# It is better than Selection Sort and Bubble Sort algorithms. number of comparisons is less
# Its space complexity is less. Like Bubble Sorting, insertion sort also requires a single additional memory space.
# It is a Stable sorting, as it does not change the relative order of elements with equal keys
# Pick second key and compare from left and insert to its suitable place


def InsertionSort(ls_insert):
  for i in range(1,len(ls_insert)):
      temp=0
      for j in range(0,i):
          if ls_insert[i]<ls_insert[j]:
              temp=ls_insert[i]
              ls_insert.pop(i)
              ls_insert.insert(j,temp)
              continue
    #print(ls_insert)
    return ls_insert

 ###Time Complexity
 
 #Best case O(n) input is sorted array
 #Worst case O(n^2) when input is reversed sorted
 #Average Case O(n^2)


#Selection sorting
# Selection sorting is conceptually the most simplest sorting algorithm.
# This algorithm first finds the smallest element in the array and exchanges 
# it with the element in the first position, then find the second smallest element 
# and exchange it with the element in the second position, and continues in this way 
# until the entire array is sorted.

def SelectSort(ls_sel):
  for i in range(0,len(ls_sel)-1):
      min_val=i
      for j in range(i+1,len(ls_sel)):
          if(ls_sel[j]<ls_sel[min_val]):
              min_val=j
              #print(min_val)
      temp=ls_sel[i]
      ls_sel[i]=ls_sel[min_val]
      ls_sel[min_val]=temp
      #print(ls_sel)
        
 ###Time Complexity
 
 #Best case O()
 #Worst case O(n^2)
 #Average Case O()

if __name__ == '__main__':
    ls=[8,1,3,1,5,2,3,4,5,2]
    
    ls_bub=BubbleSort(ls)
    print(ls_bub)
    
    ls_ins=InsertionSort(ls)
    print(ls_ins)
    ls_sel=SelectSort(ls)
    print(ls_sel)
 

